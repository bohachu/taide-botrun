# 知識檢索機制設計方案比較

## 需求分析

1. **速度快**：使用 ripgrep (rg) 高效檢索
2. **平行執行**：多組關鍵字同時檢索
3. **避免遺漏**：多重關鍵字策略
4. **上下文保留**：使用 rg -C 保留上下文

---

## 方案一：單一 rg 多模式 OR 查詢

### 設計
```bash
# 從題目選項提取關鍵字，用 -e 組合成 OR 查詢
rg -C 2 -e "厲" -e "勵" -e "蜂" -e "擁" knowledge/*.jsonl
```

### 架構
```
題目 → 提取關鍵字 → 單一 rg 命令 (多 -e) → 結果
```

### 優點
- 實作簡單，單一命令
- rg 內部優化，效能好
- 自動去重

### 缺點
- 無法控制每個關鍵字的權重/優先級
- 關鍵字太多時命令過長
- 無法針對不同知識檔案使用不同策略

### 評分

| 維度 | 分數 | 說明 |
|------|------|------|
| 速度 | 9 | 單一命令，rg 內部優化 |
| 平行度 | 6 | rg 內部平行，但無法多檔案同時 |
| 完整度 | 7 | OR 查詢可能遺漏複合條件 |
| 可維護性 | 8 | 簡單直接 |
| 彈性 | 5 | 無法區分權重 |

**總分：7.0 / 10**

---

## 方案二：Promise.all 平行多組 rg

### 設計
```javascript
// 對每個選項/關鍵字群組分別執行 rg，完全平行
const searches = [
  exec('rg -C 3 "厲|勵" knowledge/character-forms.jsonl'),
  exec('rg -C 3 "蜂擁|蜂湧" knowledge/character-forms.jsonl'),
  exec('rg -C 3 "成語" knowledge/idioms.jsonl'),
  exec('rg -C 3 "唐宋八大家" knowledge/literature.jsonl')
];
const results = await Promise.all(searches);
```

### 架構
```
題目
  ├── 選項A關鍵字 → rg 檢索 ─┐
  ├── 選項B關鍵字 → rg 檢索 ─┼── Promise.all → 合併去重 → 結果
  ├── 選項C關鍵字 → rg 檢索 ─┤
  └── 選項D關鍵字 → rg 檢索 ─┘
```

### 優點
- 完全平行，充分利用多核心
- 每組關鍵字獨立，可控制策略
- 可針對不同知識檔案
- 結果可加權排序

### 缺點
- 多個子進程開銷
- 需要合併去重邏輯
- 實作稍複雜

### 評分

| 維度 | 分數 | 說明 |
|------|------|------|
| 速度 | 10 | 完全平行，多核心利用 |
| 平行度 | 10 | Promise.all 同時執行 |
| 完整度 | 9 | 多組關鍵字避免遺漏 |
| 可維護性 | 7 | 需要管理多個搜尋 |
| 彈性 | 9 | 可針對不同情境調整 |

**總分：9.0 / 10**

---

## 方案三：預建索引 + rg 即時驗證

### 設計
```javascript
// 啟動時建立索引
const INDEX = {
  '厲': ['K-CF-001'],
  '勵': ['K-CF-001'],
  '蜂擁': ['K-CF-002'],
  '唐宋八大家': ['K-LT-001'],
  // ...
};

// 檢索時先查索引，再用 rg 取得完整內容
const ids = keywords.flatMap(kw => INDEX[kw] || []);
const content = await exec(`rg -C 3 "${ids.join('|')}" knowledge/`);
```

### 架構
```
啟動 → 掃描 JSONL → 建立 keyword→id 索引
       ↓
題目 → 關鍵字 → 查索引 → 取得 IDs → rg 取完整內容 → 結果
```

### 優點
- 索引查詢 O(1)
- 精確匹配，不會遺漏
- rg 只需取得已知 ID

### 缺點
- 需要維護索引（新知識要更新）
- 啟動時需要建立索引
- 無法處理索引外的新關鍵字
- 索引邏輯複雜

### 評分

| 維度 | 分數 | 說明 |
|------|------|------|
| 速度 | 8 | 索引快，但啟動有開銷 |
| 平行度 | 7 | 索引查詢非平行 |
| 完整度 | 6 | 只能匹配索引中的關鍵字 |
| 可維護性 | 5 | 索引需要同步維護 |
| 彈性 | 6 | 新關鍵字需要更新索引 |

**總分：6.4 / 10**

---

## 方案比較總結

| 方案 | 速度 | 平行度 | 完整度 | 可維護 | 彈性 | 總分 |
|------|------|--------|--------|--------|------|------|
| 方案一：單一 rg | 9 | 6 | 7 | 8 | 5 | **7.0** |
| 方案二：Promise.all 平行 rg | 10 | 10 | 9 | 7 | 9 | **9.0** |
| 方案三：預建索引 + rg | 8 | 7 | 6 | 5 | 6 | **6.4** |

---

## 結論

**選擇方案二：Promise.all 平行多組 rg**

理由：
1. 完全平行執行，速度最快
2. 多組關鍵字策略最能避免遺漏
3. 可針對不同題型使用不同知識檔案
4. 結果可加權合併，提高相關性

### 實作要點

1. **關鍵字提取**：從題幹 + 選項提取多組關鍵字
2. **平行搜尋**：對每個知識檔案、每組關鍵字執行 rg
3. **上下文保留**：使用 `rg -C 3` 保留前後 3 行
4. **結果合併**：去重 + 按出現頻率排序
5. **快取**：相同關鍵字結果可快取

### rg 參數設計
```bash
rg --json -C 3 -i "關鍵字" knowledge/*.jsonl
```
- `--json`：結構化輸出，便於解析
- `-C 3`：保留上下文 3 行
- `-i`：不區分大小寫
